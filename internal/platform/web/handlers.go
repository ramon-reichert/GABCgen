package web

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"time"

	gabcErrors "github.com/ramon-reichert/GABCgen/internal/platform/errors"
)

type Service interface {
	GeneratePreface(ctx context.Context, dialogue, text string) (gabc string, err error)
}

type GabcHandler struct {
	serviceAPI     Service
	requestTimeout time.Duration
}

func NewGabcHandler(service Service, reqTimeout time.Duration) GabcHandler {
	return GabcHandler{
		serviceAPI:     service,
		requestTimeout: reqTimeout,
	}
}

type PrefaceJSON struct {
	Dialogue string `json:"dialogue"`
	Text     string `json:"text"`
}

type GabcJSON struct {
	Gabc string `json:"gabc"` // GABC code generated by the service to be responded
}

/* Tests the http server connection.  */
func Ping(w http.ResponseWriter, r *http.Request) {
	method := r.Method
	if method == http.MethodGet {
		w.Write([]byte("pong"))
		return
	} else {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
}

/* Validates the entry, then generates a preface GABC. */
func (h *GabcHandler) Preface(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
		return
	}

	var prefaceEntry PrefaceJSON
	if err := json.NewDecoder(r.Body).Decode(&prefaceEntry); err != nil {
		http.Error(w, "invalid JSON body: "+err.Error(), http.StatusBadRequest)
		return
	}

	if prefaceEntry.Text == "" {
		http.Error(w, "text field is required", http.StatusBadRequest)
		return
	}

	//debug code:
	//log.Println("Received preface entry: ", prefaceEntry)

	prefaceGABC, err := h.serviceAPI.GeneratePreface(r.Context(), prefaceEntry.Dialogue, prefaceEntry.Text)
	if err != nil {
		handleError(err, w)
		return
	}

	responseJSON(w, http.StatusOK, GabcJSON{Gabc: prefaceGABC})
}

/*Writes a JSON response into a http.ResponseWriter. */
func responseJSON(w http.ResponseWriter, status int, body any) {
	w.Header().Set("content-type", "application/json")
	w.WriteHeader(status)

	//debug code:
	//log.Printf("Responding with: %+v", body)

	err := json.NewEncoder(w).Encode(body)
	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

// handleError processes errors and sends appropriate HTTP responses.
func handleError(err error, w http.ResponseWriter) {
	log.Println(err)
	var domainErr gabcErrors.DomainErr
	if errors.As(err, &domainErr) {
		domainErr.Message = err.Error()
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	} else if errors.Is(err, context.DeadlineExceeded) {
		http.Error(w, "context deadline exceeded", http.StatusGatewayTimeout)
		return
	}
	w.WriteHeader(http.StatusInternalServerError)
}
