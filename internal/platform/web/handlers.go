// Package web is the http layer adapter for the GABCgen service.
package web

import (
	"context"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"time"

	gabcErrors "github.com/ramon-reichert/GABCgen/internal/platform/errors"
)

type Service interface {
	GeneratePreface(ctx context.Context, dialogue, text string) (string, error)
}

type GabcHandler struct {
	serviceAPI     Service
	requestTimeout time.Duration
}

func NewGabcHandler(service Service, reqTimeout time.Duration) GabcHandler {
	return GabcHandler{
		serviceAPI:     service,
		requestTimeout: reqTimeout,
	}
}

type PrefaceJSON struct {
	Dialogue string `json:"dialogue"`
	Text     string `json:"text"`
}

type GabcJSON struct {
	Gabc string `json:"gabc"` // GABC code generated by the service to be responded
}

// Ping responds with "pong" to indicate the server is alive.
func Ping(w http.ResponseWriter, r *http.Request) {
	method := r.Method
	if method == http.MethodGet {
		w.Write([]byte("pong"))
		return
	} else {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
}

// Preface handles requests to generate GABC code for a given preface text.
func (h *GabcHandler) Preface(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
		return
	}

	var prefaceEntry PrefaceJSON
	if err := json.NewDecoder(r.Body).Decode(&prefaceEntry); err != nil {
		http.Error(w, "invalid JSON body: "+err.Error(), http.StatusBadRequest)
		return
	}

	if prefaceEntry.Text == "" {
		http.Error(w, "text field is required", http.StatusBadRequest)
		return
	}

	prefaceGABC, err := h.serviceAPI.GeneratePreface(r.Context(), prefaceEntry.Dialogue, prefaceEntry.Text)
	if err != nil {
		handleError(err, w)
		return
	}

	responseJSON(w, http.StatusOK, GabcJSON{Gabc: prefaceGABC})
}

// responseJSON sends a JSON response with the given status code and body.
func responseJSON(w http.ResponseWriter, status int, body any) {
	w.Header().Set("content-type", "application/json")
	w.WriteHeader(status)

	err := json.NewEncoder(w).Encode(body)
	if err != nil {
		log.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

// handleError processes errors and sends appropriate HTTP responses.
func handleError(err error, w http.ResponseWriter) {
	log.Println(err)

	var domainErr gabcErrors.DomainErr

	if errors.As(err, &domainErr) {
		domainErr.Message = err.Error()
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	} else if errors.Is(err, context.DeadlineExceeded) {
		http.Error(w, "context deadline exceeded", http.StatusGatewayTimeout)
		return
	}

	w.WriteHeader(http.StatusInternalServerError)
}
